Helpers
	letter		 = [['a'..'z']+['A'..'Z']];
	digit 		 = ['0'..'9'];

States
	normal,
	comment;

Tokens
	id 			 = ('_' | letter)('_'| letter | digit )*;
	string 		 = letter+;
	n_int		 = digit+;
	n_real		 = '-' ? digit+ '.' digit+;
	l_par        = '(';
	r_par        = ')';
	l_col		 = '[';
	r_col		 = ']';
	colon		 = ':';
	semi_c		 = ';';
	comma		 = ',';
	dot			 = '.';
	blank        = (' ' | 13 | 10)+;
	is	  		 = '<-';

	// operadores
	not	  		 = 'nao';
	and	  		 = 'e';
	or	  		 = 'ou';
	xorl  		 = 'xor';
	equal 		 = '=';
	not_equal 	 = '<>';
	menor_equal  = '<=';
	maior_equal  = '>=';
	menorq 		 = '<';
	maiorq 		 = '>';
	plus 		 = '+';
	minus 		 = '-';
	mult         = '*';
	div          = '/';
	mod          = '%';

	// palavras reservadas

	program 	= 'programa';
	begin 		= 'inicio';
	end 		= 'fim';
	while		= 'enquanto';
	end_w		= 'fim enquanto';
	for			= 'para';
	until		= 'ate';
	from		= 'de';
	end_f 		= 'fim para';
	if			= 'se';
	else		= 'senao';
	end_if		= 'fim se';
	do			= 'faca';
	real 		= 'real';
	inteiro 	= 'inteiro';
	character	= 'caractere';
	constante	= 'const';
	r 			= 'leia';
	w 			= 'escreva';
	then 		= 'entao';
	case 		= 'caso';
	repeat		= 'repita';
	pass		= 'passo';
	evaluate 	= 'avalie';
	end_e		= 'fim avalie';


Ignored Tokens
	blank;

Productions
	var = {id} id
		| {matriz} id l_col n_int r_col;

	valor = {string} string | {inteiro} n_int | {real} n_real;

	exp =
	  {val}		 	valor
	| {variavel} 	var
	| {lexpr} 		l_par exp r_par
	| {negativo}	minus exp
	| {mais}		[pre]:exp plus [pos]:exp
	| {menos}		[pre]:exp minus [pos]:exp
	| {vezes}		[pre]:exp mult [pos]:exp
	| {divisao}		[pre]:exp div [pos]:exp
	| {explog}		exp_logica;

	exp_logica =
	 {igual} 		[pre]:exp equal [pos]:exp
	|{diferente} 	[pre]:exp not_equal [pos]:exp
	|{menorigual} 	[pre]:exp menor_equal [pos]:exp
	|{maiorigual} 	[pre]:exp maior_equal [pos]:exp
	|{menorq} 		[pre]:exp menorq [pos]:exp
	|{maiorq}		[pre]:exp maiorq [pos]:exp
	|{nao} 			not exp_logica
	|{e} 			[pre]:exp_logica and [pos]:exp_logica
	|{ou} 			[pre]:exp_logica or [pos]:exp_logica
	|{xou} 			[pre]:exp_logica xorl [pos]:exp_logica;


	variavel_comma 		= {varcom} var comma;
	expr_comma 	   		= {expcom} exp comma;
	comando_semi_c 		= {comandosemi} comando semi_c;
	opcional_else  		= {elseopc} else comando_semi_c* comando semi_c;
	case_estrela   		= {casestar} case valor colon comando_semi_c* comando semi_c;
	opcional_else_colon = {elsecolonopc} else colon comando_semi_c* comando semi_c;

	comando =
	  {atrib} 		var is exp semi_c
	| {ler}			r l_par variavel_comma* var r_par semi_c
	| {escrever}	w l_par expr_comma* exp r_par semi_c
	| {se}			if l_par exp_logica r_par then comando_semi_c* comando [pre]:semi_c opcional_else? end_if [pos]:semi_c
	| {avaliar}		evaluate l_par exp r_par case_estrela* opcional_else_colon? end_e [pos]:semi_c
	| {enquanto}	while l_par exp_logica r_par do comando_semi_c* comando [pre]:semi_c end_w [pos]:semi_c
	| {repetir}		repeat comando_semi_c* comando [pre]:semi_c until l_par exp_logica r_par [pos]:semi_c
	| {paraumemum}	for var from [inicio]:n_int until [fim]:n_int do comando_semi_c* comando [pre]:semi_c end_f [pos]:semi_c
	| {parax}		for var from [inicio]:n_int pass [quantidade]:n_int until [fim]:n_int do comando_semi_c* comando [pre]:semi_c end_f [pos]:semi_c;

	tipo = {real} real |{inteiro} inteiro |{char} character;

	declaracao = {variavel} tipo colon variavel_comma* var semi_c
				| {constante} constante id valor semi_c ;

	programa = program id begin declaracao* comando* end dot;
